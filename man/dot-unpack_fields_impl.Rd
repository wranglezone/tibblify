% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unpack_tspec.R
\name{.unpack_fields_impl}
\alias{.unpack_fields_impl}
\title{Unpack all fields in a spec}
\usage{
.unpack_fields_impl(
  spec,
  fields,
  recurse,
  names_sep,
  names_repair,
  names_clean,
  .call = caller_env()
)
}
\arguments{
\item{spec}{(\code{tspec}) A tibblify specification.}

\item{fields}{(\code{character} or \code{NULL}) The fields to unpack. If \code{fields} is
\code{NULL} (default), all fields are unpacked.}

\item{recurse}{(\code{logical(1)}) Should fields inside other fields be unpacked?}

\item{names_sep}{(\code{character(1)} or \code{NULL}) If \code{NULL}, the default, the inner
names of fields are used. If a string, the outer and inner names are pasted
together, separated by \code{names_sep}.}

\item{names_repair}{(\code{character(1)} or \code{function}) Passed to the \code{repair}
argument of \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} to check that the output data frame has
valid names. Must be one of the following options:
\itemize{
\item \code{"unique"} (the default) or \code{"unique_quiet"}: make sure names are unique
and not empty,
\item \code{"universal"} or \code{"universal_quiet"}: make the names unique and syntactic
\item \code{"check_unique"}: no name repair, but check they are unique,
\item a function: apply custom name repair.
}}

\item{names_clean}{(\code{function}) A one-argument function to clean names after
repairing. For example use \code{\link[=camel_case_to_snake_case]{camel_case_to_snake_case()}}.}

\item{.call}{(\code{environment}) The environment to use for error messages.}
}
\value{
(\code{list}) A list of unpacked fields (still nested in a list
structure).
}
\description{
Unpack all fields in a spec
}
\keyword{internal}
